{"version":3,"sources":["routes/posts/2020/12/04-0007-Evolution-principles-of-software-development/document.mdx"],"names":["readingTime","text","minutes","time","words","layoutProps","MDXLayout","MDXContent","_ref","components","props","Object","_home_runner_work_mzvast_github_io_mzvast_github_io_node_modules_babel_preset_react_app_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","_mdx_js_react__WEBPACK_IMPORTED_MODULE_2__","assign","mdxType","id","parentName","isMDXComponent","tableOfContents","arguments","length","undefined","level","title","children","frontMatter"],"mappings":"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","file":"static/js/125.333def22.chunk.js","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\nexport const readingTime = {\"text\":\"1 min read\",\"minutes\":0.77,\"time\":46200,\"words\":154}\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <h2 {...{\n      \"id\": \"你可以从本文了解到\"\n    }}>{`你可以从本文了解到`}</h2>\n    <p>{`本文是对《软件设计的 201 个原则》的第9章——软件开发的演变原则的学习`}</p>\n    <p>{`演变是与修改软件产品相关的一系列工作，用于：`}</p>\n    <ol>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`满足新功能`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`更有效地运行`}</p>\n      </li>\n      <li parentName=\"ol\">\n        <p parentName=\"li\">{`正常运行（当检测到原始产品中的错误时）`}</p>\n      </li>\n    </ol>\n    <h2 {...{\n      \"id\": \"185-软件会持续变化\"\n    }}>{`185 软件会持续变化`}</h2>\n    <p>{`任何正在使用的大型软件系统都将经历不断的变化，因为系统的使用会使人想出新的功能。`}</p>\n    <p>{`它会一直变化，直到从头开始重写变得更划算。这就是曼尼·雷曼（Manny Lehman）的`}<inlineCode parentName=\"p\">{`“持续变化定律”`}</inlineCode>{`（Law of Continuing Change）。`}</p>\n    <h2 {...{\n      \"id\": \"186-软件的熵增加\"\n    }}>{`186 软件的熵增加`}</h2>\n    <p>{`任何经历持续变化的软件系统都会变得越来越复杂，并且变得越来越杂乱无章。`}</p>\n    <p>{`由于所使用的所有软件系统都会发生变化（原则 185），并且变化会导致不稳定，因此所有有用的软件系统都将朝着较低的可靠性和可维护性迁移。这就是曼尼·雷曼（Manny Lehman）的`}<inlineCode parentName=\"p\">{`“熵增加定律”`}</inlineCode>{`。`}</p>\n    <h2 {...{\n      \"id\": \"187-如果没有坏就不要修理它\"\n    }}>{`187 如果没有坏就不要修理它`}</h2>\n    <p>{`假设你在维护一个系统。你正在检查组件的源代码。你可能是想增强它，或者是想找到错误的原因。`}</p>\n    <p>{`在检查时，你觉得自己发现了另外一个错误。不要试图“修复”它。很有可能你会引入而不是修复一个错误（原则 190）。`}</p>\n    <p>{`相反，应记录并提交变更请求。期望通过配置控制和相关的技术评审来确定它是否是一个错误，以及应该以什么样的优先级进行修复。（原则 175，177，178 和 179）`}</p>\n    <h2 {...{\n      \"id\": \"188-解决问题，而不是症状\"\n    }}>{`188 解决问题，而不是症状`}</h2>\n    <p>{`当软件出错时，你的责任是彻底理解错误的原因，而不只是草草分析一下，并对你认为的原因进行一个快速的修复。`}</p>\n    <h2 {...{\n      \"id\": \"189-先变更需求\"\n    }}>{`189 先变更需求`}</h2>\n    <p>{`如果各方都同意对软件进行增强，那么第一件事就是更新软件需求规格说明（SRS: Software Requirements Specification），并获得批准。`}</p>\n    <h2 {...{\n      \"id\": \"190-发布之前的错误也会在发布后出现\"\n    }}>{`190 发布之前的错误也会在发布后出现`}</h2>\n    <p>{`发布之前错误就比较多的组件，发布之后也会发现比较多的错误。这对开发者来说是个令人失望的消息，但确实是被经验数据所充分支持的（而且由原则 114 可知，你在一个组件中发现的错误越多，将来也会发现更多）。`}</p>\n    <p>{`最好的建议是废弃、替换、从头创建任何具有不良历史记录的组件。不要花钱填坑。`}</p>\n    <h2 {...{\n      \"id\": \"191-一个程序越老，维护起来就越困难\"\n    }}>{`191 一个程序越老，维护起来就越困难`}</h2>\n    <p>{`在对软件系统进行更改（无论是维修还是增强）时，系统中必定有一些组件要被修改。`}</p>\n    <p>{`随着程序变“老”，每次改动时，整个系统中需要修改的组件的比例也会随之增加。`}</p>\n    <p>{`每次更改都会使所有后续的更改更加困难，因为程序的结构必然会恶化。`}</p>\n    <h2 {...{\n      \"id\": \"192-语言影响可维护性\"\n    }}>{`192 语言影响可维护性`}</h2>\n    <p>{`倾向于强制高内聚和低耦合（原则 73）的语言，例如 Eiffel，通常有助于开发和后续维护。级别很低的语言（如汇编语言）通常会在开发和维护期间抑制开发效率。可对照查看原则 99。`}</p>\n    <h2 {...{\n      \"id\": \"193-有时重新开始会更好\"\n    }}>{`193 有时重新开始会更好`}</h2>\n    <p>{`如今关于重建（reengineering）、翻新（renovation）和逆向工程（reverse engineering）的讨论太多了，我们可能都开始相信这样做很容易。`}</p>\n    <p>{`这很难做。有时这很有意义，值得投资。`}</p>\n    <p>{`其它时候这是对珍稀资源的浪费，从头开始设计和编码可能是更好的选择。`}</p>\n    <p>{`举例来说，扪心自问，如果你制作了设计文档，维护者们真的会使用它们吗？`}</p>\n    <h2 {...{\n      \"id\": \"194-首先翻新最差的\"\n    }}>{`194 首先翻新最差的`}</h2>\n    <p>{`原则 193 建议，重新开始有时可能是最好的主意。另一个不那么痛苦的方法是，完全重新设计和重新编码“最差”的组件。`}</p>\n    <p>{`这里“最差”的组件是指那些消耗了最多改正性维护费用的组件。`}</p>\n    <p>{`Gerald Weinberg 报告说，在一个系统中重写一个 800 行的模块（占全部改正性维护成本的 30%），就可以为整体维护工作节省大量的资源。`}</p>\n    <h2 {...{\n      \"id\": \"195-维护阶段比开发阶段产生的错误更多\"\n    }}>{`195 维护阶段比开发阶段产生的错误更多`}</h2>\n    <p>{`维护期间对程序的修改（无论是改进功能还是修正缺陷）引入的错误远远超过最初的开发阶段。维护团队报告说，维护期间有 20％ 到 50％ 的改动会引入更多错误。`}</p>\n    <p>{`出于这个原因，遵守“规则”是如此重要：制定 SCM 计划（原则 174），控制基准（原则 179），并且不要绕过变更控制（原则 182）。`}</p>\n    <h2 {...{\n      \"id\": \"196-每次变更后都要进行回归测试\"\n    }}>{`196 每次变更后都要进行回归测试`}</h2>\n    <h2 {...{\n      \"id\": \"197-变更很容易的想法，会使变更更容易出错\"\n    }}>{`197 “变更很容易”的想法，会使变更更容易出错`}</h2>\n    <p>{`为了避免这种情况，要确保你正在做的变更是经过核准的（原则 182 及 183 ），对每项变更进行核查（原则 97），并在每组变更后进行回归测试（原则 196）。`}</p>\n    <h2 {...{\n      \"id\": \"198-对非结构化代码进行结构化改造，并不一定会使它更好\"\n    }}>{`198 对非结构化代码进行结构化改造，并不一定会使它更好`}</h2>\n    <p>{`相反的，你应该采用合理的软件工程原则，重新考虑模块，并从头开始重新设计。`}</p>\n    <h2 {...{\n      \"id\": \"199-在优化前先进行性能分析\"\n    }}>{`199 在优化前先进行性能分析`}</h2>\n    <p>{`当需要优化程序以使其更快时，请记住 `}<inlineCode parentName=\"p\">{`80% 的CPU周期将被 20% 的代码消耗`}</inlineCode>{`（Pareto定律）。`}</p>\n    <p>{`因此，先去找到那些能够带来优化效果的 20% 的代码。`}</p>\n    <p>{`最好的方法是使用任何市场上可买到的可用的性能分析工具。`}</p>\n    <p>{`性能分析工具在你的程序运行过程中监控它，并识别出“热点”，也就是消耗最多 CPU 周期的部分。优化这部分。`}</p>\n    <h2 {...{\n      \"id\": \"200-保持熟悉\"\n    }}>{`200 保持熟悉`}</h2>\n    <p>{`这就是 Manny Lehman 的“熟悉守恒定律”（Law of Conservation of Familiarity）。`}</p>\n    <p>{`软件修改的时间越长，开发人员对它的“感觉”就越陌生。`}</p>\n    <p>{`总结：保持产品发布版本之间的改动量相对稳定。`}</p>\n    <h2 {...{\n      \"id\": \"201-系统的存在促进了演变\"\n    }}>{`201 系统的存在促进了演变`}</h2>\n    <p>{`系统引入到它要解决的问题的环境中，本身就改变了这个环境，也就会引发新的问题。`}</p>\n    <p>{`无论你认为自己多完美地实现了需求，都必须为部署之后必要的变更做好计划。`}</p>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;\nexport const tableOfContents = (components={}) => [\n  {\n    id: \"你可以从本文了解到\",\n    level: 2,\n    title: \"你可以从本文了解到\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"185-软件会持续变化\",\n    level: 2,\n    title: \"185 软件会持续变化\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"186-软件的熵增加\",\n    level: 2,\n    title: \"186 软件的熵增加\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"187-如果没有坏就不要修理它\",\n    level: 2,\n    title: \"187 如果没有坏就不要修理它\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"188-解决问题，而不是症状\",\n    level: 2,\n    title: \"188 解决问题，而不是症状\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"189-先变更需求\",\n    level: 2,\n    title: \"189 先变更需求\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"190-发布之前的错误也会在发布后出现\",\n    level: 2,\n    title: \"190 发布之前的错误也会在发布后出现\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"191-一个程序越老，维护起来就越困难\",\n    level: 2,\n    title: \"191 一个程序越老，维护起来就越困难\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"192-语言影响可维护性\",\n    level: 2,\n    title: \"192 语言影响可维护性\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"193-有时重新开始会更好\",\n    level: 2,\n    title: \"193 有时重新开始会更好\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"194-首先翻新最差的\",\n    level: 2,\n    title: \"194 首先翻新最差的\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"195-维护阶段比开发阶段产生的错误更多\",\n    level: 2,\n    title: \"195 维护阶段比开发阶段产生的错误更多\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"196-每次变更后都要进行回归测试\",\n    level: 2,\n    title: \"196 每次变更后都要进行回归测试\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"197-变更很容易的想法，会使变更更容易出错\",\n    level: 2,\n    title: \"197 “变更很容易”的想法，会使变更更容易出错\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"198-对非结构化代码进行结构化改造，并不一定会使它更好\",\n    level: 2,\n    title: \"198 对非结构化代码进行结构化改造，并不一定会使它更好\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"199-在优化前先进行性能分析\",\n    level: 2,\n    title: \"199 在优化前先进行性能分析\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"200-保持熟悉\",\n    level: 2,\n    title: \"200 保持熟悉\",\n    children: [\n        \n      ]\n  },\n{\n    id: \"201-系统的存在促进了演变\",\n    level: 2,\n    title: \"201 系统的存在促进了演变\",\n    children: [\n        \n      ]\n  }\n]\n\nexport const frontMatter = {}\n\n"],"sourceRoot":""}